/* Черкашин Дмитрий.
Домашнее задание №10. Задача 3. По одному разу.
MFTI_Homeworks DZ10 main3.c
06.04.24
Условие:            В файле .txt даны два слова не более 100 символов каждое, разделенные одним пробелом.
                    Найдите только те символы слов, которые встречаются в обоих словах только один раз.
                    Напечатайте их через пробел в файл .txt в лексикографическом порядке


Данные на входе:    Два слова из маленьких английских букв через пробел. Длинна каждого слова не больше 100 символов.
Данные на выходе: 	Маленькие английские буквы через пробел.

Пример №1
Данные на входе: 	hello world
Данные на выходе: 	o

Пример №2
Данные на входе: 	aabcd bcef 
Данные на выходе: 	b c         */

/* Подключение библиотеки стандартного ввода-вывода для работы функций*/
#include <stdio.h>

/* Длина массива через директиву препроцессора*/
#define ARR_WIDTH 101

/* *input_fn - указатель на имя файла для чтения input.txt
    тип - char */
char *input_fn = "input.txt";

/*  *output_fn - указатель на имя файла для чтения output.txt
    тип - char */
char *output_fn = "output.txt";

/*  Прототип функции обработки данных из файла
    согласно условию задачи */
int one_at_time (char *arr, char *var_arr, int count, int space_pointer);

/*  Прототип функции сортировки массива символов
    согласно условию задачи */
void sort_var_arr (int index_var_arr, char *arr_var);

/* main - вход в программу */
int main(void)
{

    /*  arr - для приёма данных из файла
        var_arr - для обработанных данных
        тип - char 
        инициализироваы как нулевые*/
    char arr[ARR_WIDTH*2] = {0}, var_arr[ARR_WIDTH]={0};

    /*  c - переменная для работы с данными из файла
        тип - char */
    char c;

    /*  *fp - указатель для работы с внешними файлами 
        тип - FILE */
    FILE *fp;

    /*  Проверка на наличие файла input.txt */
    if ((fp = fopen(input_fn, "r")) == NULL)
    {
        /* Вывод ошибки из потока ошибок. */
        perror("Error occured while opening input file!");
        return 1;
    }

    /* count - счётчик длины массива. Инициализирован как 0 
       space_pointer - индекс символа пробела 
       тип int*/
    int count = 0, space_pointer, index_var_arr;

    /* Считываем посимвольно пока не конец файла или не перевод строки */
    while (((c = getc(fp)) != EOF) && (c != '\n'))
    {
        /* Присвоить текущее значение символа из файла
        по текущему индексу с постинкрементом */
        arr[count++] = c;
        /* Если символ пробел */
        if (c == ' ')
        {
            /* Запомнить индекс символа пробела*/
            space_pointer = count-1;
        }
    }

    /* Закроем поток данных по указателю fp */
    fclose(fp);

    /* Вызов функции реализующей требование условия задачи*/
    index_var_arr = one_at_time (arr, var_arr, count, space_pointer);
    
    /* Отсортируем полученный массив согласно требованию задачи*/
    sort_var_arr(index_var_arr, var_arr);

    /* Создадим и откроем файл на запись */
    if ((fp = fopen(output_fn, "w")) == NULL)
    {
        /* Вывод ошибки в случае нарушения работы функции*/
        perror("Error occured while opening output file!");
        return 1;
    }


    /* Вывод полученных значений*/
    for (int i = 0; i < count; i++)
    {
        /* Если нулевое значение - прервать*/
        if (var_arr[i]=='\0')
        {
            break;
        }
        /* Посимвольный вывод значений из второго массива */
        fprintf(fp, "%c ", var_arr[i]);
    }
    
    /* Закрыть файл */
    fclose(fp);

    return 0;
}

/* one_at_time - функция обработки полученных данных из файла
Принимает:
1) *arr - указатель на массив arr
2) *var_arr -указатель на массив var_arr
3) count - значение числа считанных элементов
4) space_pointer - индекс символа пробела из массива 
Ничего не возвращает*/
int one_at_time (char *arr, char *var_arr, int count, int space_pointer)
{
    /*  count1 - для подсчёта повторяющихся символов до пробела 
        count2 - для подсчёта повторяющихся символов после пробела 
        index_var_arr - проинициализированный счётчик по движению для
        вспомогательного массива 
        тип- int */
    int count1, count2, index_varr_arr=0;

    /* Двигаемся по массиву до пробела */ 
    for (int i = 0; i < space_pointer; i++)
    {
        /* Занулить оба счётчика повторений */
        count1 = 0;
        count2 = 0;

        /* Первый вспомогательный проход по левой части массива до пробела*/
        for (int j = 0; j < space_pointer; j++)
        {
            /* Если значения символов совпали */
            if (arr[i]==arr[j])
            {
                count1++; // Увеличить первый счётчик 
            }
        }

        /* Второй вспомогательный проход по правой части массива до пробела*/
        for (int k = count-1; k > space_pointer; k--)
        {
            /* Если значения символов совпали */
            if (arr[i]==arr[k])
            {
                count2++; // Увеличить второй счётчик
            }
        }
        
        /* Если выполнилось условие задачи*/
        if (count1==1 && count2==1)
        {
            /* Записать в доп массив текущий символ с постиинкрементом */
            var_arr[index_varr_arr++]=arr[i];
        }
    }
    /* Преобразовать доп. массив в строку */
    var_arr[index_varr_arr]='\0';
}

    
/* sort_var_arr - функция сортировки массива символов
Принимает:
1) index_var_arr - длинну масива выходных данных
2) *var_arr -указатель на массив var_arr 
Ничего не возвращает*/
void sort_var_arr(int index_var_arr, char *var_arr)
{ 
    /*  temp - переменная для замещений символов
        тип  - char*/
    char temp;

    for (int i = 0; i < index_var_arr; ++i)
    {
        for (int j = index_var_arr - 1; j > i; --j)
        {
            if (var_arr[i] > var_arr[j])
            {
                temp = var_arr[i];
                var_arr[i] = var_arr[j];
                var_arr[j] = temp;
            }
        }
    }
}