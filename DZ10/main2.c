/*Черкашин Дмитрий. 
Домашнее задание №10. Задача 2. Последний номер символа. 
MFTI_Homeworks DZ10 main2.c
06.04.24
Условие:            В файле .txt дана строка из 1000 символов. 
                    Показать номера символов, совпадающих с последним символом строки. 
                    Результат записать в файл .txt 


Данные на входе:    Строка не более 1000 символов. 
Данные на выходе: 	Целые числа через пробел - номера символа, который совпадает с последним символом строки. 

Пример
Данные на входе: 	aabbcdb 
Данные на выходе: 	2 3     */

/* Подключение библиотеки стандартного ввода-вывода 
для работы функций*/
#include <stdio.h> 

/* Дирректива для препроцессора, для объявления длины массива*/ 
#define LINE_WIDTH 1000

/* Точка входа в программу функция main */ 
int main(void)
{
    /* Объявим указатель input_fn на строку типа char */
    char *input_fn = "input.txt";

    /* Объявим указатель output_fn на строку типа char */
    char *output_fn = "output.txt";

    /* Объявим нулевой массива line типа char,
    длина определяется препроцессорной директивой
    для хранения данных из файлы */
    char line[LINE_WIDTH]={0};

    /* Объявим переменную c типа char
    для последующего копирования данных из файла в во временный массив */
    char c;

    /* Объявим указатель типа FILE для работы с внешними файлами */
    FILE *fp;  

    /* Откроем поток функцией fopen из файла по указателю на чтение.  
    Если функция fopen не смогла найти и открыть файл по указателю input_fn
    и вернула нулевое значение в указатель fp*/
    if((fp = fopen(input_fn, "r")) == NULL)
    {
        /* Если условие верно вывести на экран строку как аргумент функции
        и сообщение об ошибке через двоеточие */
        perror("Error occured while opening input file!");

        /* Функция main вощвращает ненулевое значение */
        return 1;
    }
    
    /* Объявим и инициализируем цельночисленный счётчик count*/
    int count = 0;
    
    /* Пока считываемый символ функцией getc из файла не является
    концом файла и символом перевода строки */
    while(((c = getc(fp)) != EOF) && (c != '\n'))
    {
        /* В ячейку временного массива line записать значение считанной переменной
        и увеличить значение ячейки постинкрементом*/
        line[count++] = c;
    }
  	/* В конец массива помещать \0 не будем, так как все ячейки массива,
    которые не перезаписаны в процессе считывания данных из файла являются нулями*/
    
    /* Функцией fclose сохраним в файл данные, находящиеся в буфере,
    и закроем ранее открытый поток  */
    fclose(fp);	
    
    /* Откроем поток на запись, функцией fopen по указателю
    Если при открытиее файла произошли ошибки, и функция вернула 0 */
    if((fp = fopen(output_fn, "w")) == NULL)
    {
        /* Если условие верно вывести на экран строку как аргумент функции
        и сообщение об ошибке через двоеточие */
        perror("Error occured while opening output file!");

        /* Функция main вощвращает ненулевое значение */
        return 1;
    } 	
    
    /* Для i от 0 до значения счётчика символов в строке -1 */
    for (int i = 0; i < count-1; i++)
    {
        /* Если значение текущей ячейке массива
        равно последнему символу*/
        if (line[i]==line[count-1])
        {
            /* Вывести в файл номер символа согласно условию задачи*/
            fprintf(fp, "%d ", i);
        }
    }

    /* Функцией fclose сохраним в файл данные, находящиеся в буфере,
    и закроем ранее открытый поток  */
    fclose(fp);

    /* Если функция main выполнена без ошибок 
    вернуть 0 */
    return 0;
}