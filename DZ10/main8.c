/* Черкашин Дмитрий.
Домашнее задание №10. Задача 8. Заканчивается на a.
MFTI_Homeworks DZ10 main8.c
13.04.24
Условие:            В файле .txt дано предложение.
                    Необходимо определить, сколько слов заканчиваются на букву 'а'.
                    Ответ записать в файл .txt.

Данные на входе: 	Строка из английских букв и пробелов не более 1000 символов.
Данные на выходе: 	Одно целое число.

Пример
Данные на входе: 	Mama mila ramu
Данные на выходе: 	2  */

/* Подключение библиотеки стандартного ввода-вывода для работы функций*/
#include <stdio.h>

/* Подключение библиотеки тестирования и сопоставления символов */
#include <ctype.h>

/* *input_fn - указатель на имя файла для чтения input.txt
    тип - char */
char *INPUT_FILE_NAME = "input.txt";

/* *output_fn - указатель на имя файла для чтения input.txt
    тип - char */
char *OUTPUT_FILE_NAME = "output.txt";

/*  Прототип функции inc_data */
int inc_data(char *arr_char);

/*  Прототип функции end_a_count*/
void end_a_count(int *count_a, char *arr_char);

/*  Прототип функции out_data */
int out_data(int *count_a);

#define ARR_WIDTH 1000

/*  main - вход в программу */
int main(void)
{
    /*  arr_char - массив хранения входных данных
        инициализирован нулями
        тип - char */
    char arr_char[ARR_WIDTH] = {0};

    /*  a - счётчик слов, удовлетворяющих условию задачи
        тип - int */
    int a = 0;

    /*  *сount_a - указатель на счётчик а
        тип int */
    int *count_a = &a;

    /*  Вызов функции записи входящих данных и
        проверка на работу без ошибок */
    if (inc_data(arr_char) == 1)
    {
        return 1;
    }

    /*  Вызов функции подсчёт слов заканчивающихся на а */
    end_a_count(count_a, arr_char);

    /*  Вызов функции записи обработанных данных в файл
        проверка на работу без ошибок */
    if (out_data(count_a) == 1)
    {
        return 1;
    }

    /* Вернуть 0, если нет ошибок */
    return 0;
}

/*  incoming_data - функция приёма данных из файла
    Удаляет все лишние входящие пробелы. Для удобства последующей обработки.
    Принимает:
    *arr - указатель на массив arr
    Возвращает:
    1 - при ошибке
    0 - при их отсутсвии */
int inc_data(char *arr_char)
{
    /*  *fp - указатель на файл
        тип - FILE */
    FILE *fp;

    /*  Проверка на наличие файла input.txt */
    if ((fp = fopen(INPUT_FILE_NAME, "r")) == NULL)
    {
        /* Вывод ошибки из потока ошибок. */
        perror("Error occured while opening input file!");
        /* Вернуть 1 в точку вызова */
        return 1;
    }

    /*  i - счётчик для работы с массивом
        инициализирован 0
        space_flag - флаг учёта считываемых пробелов
        тип - int */
    int i = 0, space_flag = 1;

    /*  c - переменная для работы с данными из файла
        тип - char */
    char c;

    /*  Считываем посимвольно пока не конец файла или не перевод строки
        и подготовим массив к дальнешей обработке:
        1) Пропустим все пробелы вначале предложения
        2) Между словами оставим лишь 1 пробел */
    while (((c = getc(fp)) != EOF) && (c != '\n'))
    {
        /*  Если считанный символ space и
            флаг опущен */
        if (isspace(c) && !space_flag)
        {
            /* Присвоить пробел */
            arr_char[i++] = c;
            /* Взвести флаг*/
            space_flag = 1;
            /* Продолжить итерации цикла */
            continue;
        }
        /* Иначе если флаг поднят */
        else if (isspace(c) && space_flag)
        {
            /* Продолжить итерации цикла */
            continue;
        }
        /* Записываем посимвольно в массив arr_char*/
        arr_char[i++] = c;
        space_flag = 0;
    }

    /* Добавить пробел в конец массива для дальнейшей обработки */
    arr_char[i] = ' ';

    /* Закрытие файла */
    fclose(fp);

    /* Вернуть 0 , если нет ошибок */
    return 0;
}

/*  end_a_count - Функция вычисления количества слов,
    заканчивающихся на а
    Принимает:
    1) Указатель на счётчик слов, удовлетворяющих условию
    2) Указатель на массив *arr_char
    Ничего не возвращает */
void end_a_count(int *count_a, char *arr_char)
{
    /* Проход по массиву */
    for (int i = 0; i < ARR_WIDTH - 1; i++)
    {
        /* Если текущее значение пробел и предыдущее а или А */
        if (arr_char[i] == ' ' && (arr_char[i - 1] == 'a' || arr_char[i - 1] == 'A'))
        {
            /* Счётчик по указателю увеличить*/
            (*count_a)++;
        }
    }
}

/*  outgoing_data - функция отправки данных в файл.
    Принимает:
    i - счётчик слов, удовлетворяющих условию задачи
    Возвращает:
    1 при ошибке
    0 при их отсуствии */
int out_data(int *count_a)
{
    /*  *fp - указатель на файл
        тип - FILE */
    FILE *fp;

    /*  Проверка на наличие файла input.txt */
    if ((fp = fopen(OUTPUT_FILE_NAME, "w")) == NULL)
    {
        /* Вывод ошибки из потока ошибок. */
        perror("Error occured while opening output file!");
        /* Вернуть 1 в точку вызова */
        return 1;
    }
    
    /* Записать в файл вычисленное значение */
    fprintf(fp, "%d", *count_a);

    /* Закрыть файл */
    fclose(fp);

    /* Вернуть 0 */
    return 0;
}