/*Черкашин Дмитрий. 
Домашнее задание №9. Задача 5. Пропущенное число
MFTI_Homeworks DZ9 main5.c
01.04.24
Условие:            Написать функцию и программу, демонстрирующую работу данной функции.
                    В последовательности записаны целые числа от M до N 
                    ( M меньше N, M больше или равно 1) в произвольном порядке, 
                    но одно из чисел пропущено (остальные встречаются ровно по одному разу). 
                    N не превосходит 1000. Последовательность заканчивается числом 0. 
                    Определить пропущенное число
Вход:               Последовательность целых чисел от M до N. M, N не превосходит 1000
Выход:              Одно целое число */

#include <stdio.h>  // Подключим стандартную библиотеку ввода вывода
#define VAL_ARR 100  // Значение длины массива для данных, через препроцессорный макрос

int Arr_Input(int n, int *arr);           // Объявление прототипа функции инициализации
void Arr_Bubble_Sort(int n, int *arr);    // Объявление прототипа функции сортировки массива пузырьком
void Arr_Find_Miss(int n, int *arr);      // Объявление прототипа функции поиска пропущенного значения

int main (void)
{
    /* Объявим массивы arr типа int длинной ARR_VAL
    и переменную count для ограничения ОДЗ массива */
    int arr[VAL_ARR], count;
    
    /* Вызов функции инициализации массива и возвращение
    значение индекса крайнего рабочего элемента */
    count = Arr_Input(VAL_ARR, arr);


    /* Вывов функции сортировки пузырьком, для выстраивания введённых данных
    по возрастанию, для удобства последующих вычисленйи*/
    Arr_Bubble_Sort(count, arr);

    /* Вызов функции поиска пропущенного значение*/
    Arr_Find_Miss(count, arr);

    return 0;
}

/* Функция Arr_Input инициализации массива 
Принимает:
1) Длину массива    
2) Указатель на массив *arr 
Записывает все значения последовательно в массив
до достижения граничного условия
Возвращает индекс крайнего элемента массива*/
int Arr_Input(int n, int *arr)
{
    /* Проход по массиву */
    for (int i = 0; i < n; i++)
    {
        /* Считываем значение из потока вводе */
        scanf("%d", &arr[i]);

        /* Если значение равну нулю */
        if (arr[i]==0)
        {
            /* Вернуть в значение индекса */
            return i;
            /* Прервать итерацию цикла */
            break;
        }
    }
}

/* Функция сортировки пузырьком полученного
на вход массива */
void Arr_Bubble_Sort ( int n , int *arr)
{
    int arr_var;
    /* Общее количество проходов по массиву n-1*/
    for (int i = 0; i < n-1; i++)
    {
        /* Двигаемся от крайнего правого элемента пока
        счётчик итерации больше предыдущего счётчика*/
        for (int j = n-1 ; j > i; j--)
        {
            /* Если элемент левее больше чем элемент правее*/
            if (arr[j-1]>arr[j])
            {
                /* Поменяем их местами через доп переменную*/
                arr_var=arr[j-1];
                arr[j-1]=arr[j];
                arr[j]=arr_var;
            }
        }
    }
}

/* Функция Arr_Find_Miss поиска пропущенного 
Принимает:
1) Длину массива    
2) Указатель на массив *arr 
Поиск по массиву пропущенного элемента
Ничего не возвращает*/
void Arr_Find_Miss (int n, int *arr)
{
    /* Цикл прохода по массиву */
    for (int i = 0; i < n; i++)
    {
        /* Если разность впередистоящего элемента
        с текущим, превышает еденицу в натуральном ряду чисел
        значит иммет место быть пропущенное число*/
        if ((arr[i+1]-arr[i])>1)
        {
            /* Вывести на экран значение текущего числа +1*/
            printf("%d\n", (arr[i]+1));
            /*Прервать цикл. Условие задачи выполнено*/
            break;
        }
    }
}